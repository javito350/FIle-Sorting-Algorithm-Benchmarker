# File Sorting

## Table of Contents

## Javier Bejarano

## Re-type the sentence "I adhered to the Allegheny College Honor Code while completing this project."

I adhered to the Allegheny College Honor Code while completing this project.

**IMPORTANT:** If you do not type the required sentence then the course
instructor will not know that you adhered to the Allegheny College Honor Code
while completing the project.

## References

Copilot: I used copilot to help me with the implementation of the program.

## Program Output

### Report at least two examples of program output from when you ran the `systemsense` program

#### First output from running the `systemsense` program

Output from running the program on my windows Laptop:

```text

Displaying System Information

â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  System Information Panel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•® â”‚
â”‚ â”‚ System Parameter â”‚ Parameter Value                                                                        â”‚ â”‚
â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚
â”‚ â”‚ battery          â”‚ 62.00% battery life remaining, unknown seconds remaining                               â”‚ â”‚
â”‚ â”‚ cpu              â”‚ AMD64                                                                                  â”‚ â”‚
â”‚ â”‚ cpucores         â”‚ 8                                                                                      â”‚ â”‚
â”‚ â”‚ cpufrequencies   â”‚ Min: 0.0 Mhz, Max: 2112.0 Mhz                                                          â”‚ â”‚
â”‚ â”‚ datetime         â”‚ 2025-01-23 21:49:47                                                                    â”‚ â”‚
â”‚ â”‚ disk             â”‚ Using 96.58 GB of 475.84 GB                                                            â”‚ â”‚
â”‚ â”‚ hostname         â”‚ DESKTOP-MEH0K09                                                                        â”‚ â”‚
â”‚ â”‚ memory           â”‚ 31.88 GB                                                                               â”‚ â”‚
â”‚ â”‚ platform         â”‚ Windows                                                                                â”‚ â”‚
â”‚ â”‚ pythonversion    â”‚ 3.12.1                                                                                 â”‚ â”‚
â”‚ â”‚ runningprocesses â”‚ 294                                                                                    â”‚ â”‚
â”‚ â”‚ swap             â”‚ Total: 2.00 GB, Used: 0.08 GB, Free: 1.92 GB                                           â”‚ â”‚
â”‚ â”‚ system           â”‚ 64bit                                                                                  â”‚ â”‚
â”‚ â”‚ systemload       â”‚ System load information is not available on Windows.                                   â”‚ â”‚
â”‚ â”‚ virtualenv       â”‚ /Users/Javier/Documents/Computer_Science202_Fullcourse/Project_1_Algorithmology_Sys... â”‚ |
â”‚ â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯ â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯


Displaying Benchmark Results

â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Benchmark Information Panel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®             â”‚
â”‚ â”‚ Benchmark Name               â”‚ Benchmark Results (sec)                                        â”‚             â”‚
â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤             â”‚
â”‚ â”‚ benchmark_addition           â”‚ [1.945940500125289, 1.9330923995003104, 2.015283400192857]     â”‚             â”‚
â”‚ â”‚ benchmark_exponentiation     â”‚ [3.7314814999699593, 3.6686081998050213, 3.693094700574875]    â”‚             â”‚
â”‚ â”‚ benchmark_multiplication     â”‚ [1.5873325001448393, 1.5692357998341322, 1.5867868000641465]   â”‚             â”‚
â”‚ â”‚ rangelist                    â”‚ [0.22485849913209677, 0.20735279936343431, 0.2036055000498891] â”‚             â”‚
â”‚ â”‚ time_benchmark_concatenation â”‚ [5.881490300409496, 5.487309699878097, 6.508231399580836]      â”‚             â”‚
â”‚ â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯             â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
```

#### Second output from running the `systemsense` program

Output from running the program on ubuntu through github actions:

```text
Displaying System Information

â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ System Information â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•® â”‚
â”‚ â”‚ System Parameter â”‚ Parameter Value                                                                                           â”‚ â”‚
â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚
â”‚ â”‚ battery          â”‚ No battery is present                                                                                     â”‚ â”‚
â”‚ â”‚ cpu              â”‚ x86_64                                                                                                    â”‚ â”‚
â”‚ â”‚ cpucores         â”‚ 2                                                                                                         â”‚ â”‚
â”‚ â”‚ cpufrequencies   â”‚ Min: 0.0 Mhz, Max: 0.0 Mhz                                                                                â”‚ â”‚
â”‚ â”‚ datetime         â”‚ 2025-01-24 02:39:20                                                                                       â”‚ â”‚
â”‚ â”‚ disk             â”‚ Using 47.39 GB of 71.61 GB                                                                                â”‚ â”‚
â”‚ â”‚ hostname         â”‚ fv-az1131-112                                                                                             â”‚ â”‚
â”‚ â”‚ memory           â”‚ 7.75 GB                                                                                                   â”‚ â”‚
â”‚ â”‚ platform         â”‚ Linux                                                                                                     â”‚ â”‚
â”‚ â”‚ pythonversion    â”‚ 3.12.8                                                                                                    â”‚ â”‚
â”‚ â”‚ runningprocesses â”‚ 129                                                                                                       â”‚ â”‚
â”‚ â”‚ swap             â”‚ Total: 3.00 GB, Used: 0.00 GB, Free: 3.00 GB                                                              â”‚ â”‚
â”‚ â”‚ system           â”‚ 64bit                                                                                                     â”‚ â”‚
â”‚ â”‚ systemload       â”‚ Average Load: 0.61, CPU Utilization: Unknown                                                              â”‚ â”‚
â”‚ â”‚ virtualenv       â”‚ Not Available                                                                                             â”‚ â”‚
â”‚ â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯ â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯


Displaying Benchmark Results

â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Benchmark Information Panel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®             â”‚
â”‚ â”‚ Benchmark Name               â”‚ Benchmark Results (sec)                                        â”‚             â”‚
â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤             â”‚
â”‚ â”‚ addition                     â”‚ [1.499241847999997, 1.4721593159999884, 1.4720247559999962]    â”‚             â”‚
â”‚ â”‚ concatenation                â”‚ [3.8086325510000165, 3.8252644309999937, 3.868314713000018]    â”‚             â”‚
â”‚ â”‚ exponentiation               â”‚ [3.0969970730000114, 3.1163217720000205, 3.050101438000013]    â”‚             â”‚
â”‚ â”‚ multiplication               â”‚ [1.2175857599999915, 1.192235927000013, 1.2040489809999997]    â”‚             â”‚
â”‚ â”‚ rangelist                    â”‚ [0.1430895459999988, 0.15392396999999391, 0.14262091899999518] â”‚             â”‚
â”‚ â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯             â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
```

### Use fenced code blocks to provide output from five different runs of `filesorter` with five different inputs

Provide the complete command-line for your use of the `filesorter` program

#### Command: poetry run filesorter --attribute name  --approach lambdafunction --input-file input/people.txt --output-file output/people.txt

```text
ğŸ§® Reading in the data from the specified file input\people.txt
â± Time to read the data in 0.02 seconds

ğŸš€ Parsing the data file and transforming it into people objects

ğŸƒ Sorting the people according to the name

ğŸ’¥ Using a sorting approach called lambdafunction

âœ¨ Saving the sorted people data to the file output\people.txt
â± Time to write the data 0.17 seconds

ğŸ”¬ Time to Sort Person Data Using Iterative Bubble sort (ms): 33.23 ms
```

#### Command: poetry run filesorter --attribute job  --approach lambdafunction --input-file input/people.txt --output-file output/people.txt

```text
ğŸ§® Reading in the data from the specified file input\people.txt
â± Time to read the data in 0.02 seconds

ğŸš€ Parsing the data file and transforming it into people objects

ğŸƒ Sorting the people according to the job

ğŸ’¥ Using a sorting approach called lambdafunction

âœ¨ Saving the sorted people data to the file output\people.txt
â± Time to write the data 0.20 seconds

ğŸ”¬ Time to Sort Person Data Using Iterative Bubble sort (ms): 32.90 ms
```

#### Command: poetry run filesorter --attribute name  --approach customcompare --input-file input/people.txt --output-file output/people.txt

```text
 Reading in the data from the specified file input\people.txt
â± Time to read the data in 0.02 seconds

ğŸš€ Parsing the data file and transforming it into people objects

ğŸƒ Sorting the people according to the name

ğŸ’¥ Using a sorting approach called customcompare

âœ¨ Saving the sorted people data to the file output\people.txt
â± Time to write the data 0.16 seconds

ğŸ”¬ Time to Sort Person Data Using Iterative Custom Comperator (ms): 181.31 ms
```

#### Command: poetry run filesorter --attribute job  --approach customcompare --input-file input/people.txt --output-file output/people.txt

```text
ğŸ§® Reading in the data from the specified file input\people.txt
â± Time to read the data in 0.02 seconds

ğŸš€ Parsing the data file and transforming it into people objects

ğŸƒ Sorting the people according to the job

ğŸ’¥ Using a sorting approach called customcompare

âœ¨ Saving the sorted people data to the file output\people.txt
â± Time to write the data 0.16 seconds

ğŸ”¬ Time to Sort Person Data Using Iterative Custom Comperator (ms): 163.17 ms
```

#### Command: poetry run filesorter --attribute phone_number  --approach customcompare --input-file input/people.txt --output-file output/people.txt

```text
ğŸ§® Reading in the data from the specified file input\people.txt
â± Time to read the data in 0.02 seconds

ğŸš€ Parsing the data file and transforming it into people objects

ğŸƒ Sorting the people according to the phone_number

ğŸ’¥ Using a sorting approach called customcompare
ğŸ”¬ Time to Sort Person Data Using Iterative Custom Comperator (ms): 212.28 ms
```

## Experiment Design

Describe your design of the `filesorter` experiment that answers your own
research questions (as specified in the next subsection), focusing on these key
issues:

- **Data file**: either subsets of or the entire `input/people.txt` file or
alternative files that contain rows of data with `Person` attributes that can be
parsed and then transformed into instances of the `Person` class; this aspect of
the experiment may also investigate both the number of rows inside of the data
file and the contents of each row inside of the data file.
- **Sorting algorithms**: the sorting algorithms that the `filesorter` uses to
sort the instances of the `Person` class that are stored in memory.
- **Input time**: the time overhead associated with reading in the specified
data file.
- **Output time**: the time overhead associated with writing to a specified file
all the details about each matching instance of the `Person` class.
- **Sorting time**: the time overhead associated with sorting the in-memory
representation of the input data file stored in a list of `Person` objects.

The **Sorting time** is a critical part of the experiment and, as you study it,
please make sure that you consider how the performance of sorting may be
influenced by, for instance, the size and contents of the data file and the
attribute that was chosen to organize the data file. Please note that you must
justify every part of your experiment design and then furnish output examples to
demonstrate that your program generates correct data! Finally, don't forget that
you should not start to run your experiments until you are convinced that the
each sorting algorithm configuration produces the correct output file.

## Research Questions

- RQ1: What is the time overhead associated with sorting the data by the name attribute using the lambda function approach?

The time overhead for sorting the data by the name attribute using the lambda function approach is 33.23 ms for the full input size and 16.12 ms for half the input size. This demonstrates that the runtime decreases proportionally with the input size, consistent with the expected time complexity of O(n log n). The lambda function approach is efficient for sorting smaller datasets and provides a straightforward way to define custom sorting logic. However, for larger datasets, its performance is slightly slower compared to optimized approaches like attrgetter.

- RQ2: What happens with the runtime of the sorting algorithms as the input size increases?

Let's analyze the output of the program when sorting the data by the job attribute using the customcompare function approach:

Output with normal input size:

```text
ğŸ§® Reading in the data from the specified file input\people.txt
â± Time to read the data in 0.02 seconds

ğŸš€ Parsing the data file and transforming it into people objects

ğŸƒ Sorting the people according to the job

ğŸ’¥ Using a sorting approach called customcompare

âœ¨ Saving the sorted people data to the file output\people.txt
â± Time to write the data 0.16 seconds

ğŸ”¬ Time to Sort Person Data Using Iterative Custom Comperator (ms): 163.17 ms
```

Output with half input size:

```text
ğŸ§® Reading in the data from the specified file input\people.txt
â± Time to read the data in 0.01 seconds

ğŸš€ Parsing the data file and transforming it into people objects

ğŸƒ Sorting the people according to the job

ğŸ’¥ Using a sorting approach called customcompare

âœ¨ Saving the sorted people data to the file output\people.txt
â± Time to write the data 0.10 seconds

ğŸ”¬ Time to Sort Person Data Using Iterative Custom Comperator (ms): 115.32 ms
```

As we can see in the output, the time to sort the data by the job attribute using the customcompare function approach is 163.17 ms with the normal input size and 115.32 ms with half the input size, which means that the runtime decreases as the input size decreases. This is consistent with the expected time complexity of O(n log n) for sorting algorithms. The customcompare approach is efficient for sorting larger datasets, but its performance may vary depending on the specific sorting criteria and the size of the dataset.

- RQ3: How much time the program takes to read the data from the specified file?

The program takes 0.02 seconds to read the data from the specified file for the full input size and 0.01 seconds for half the input size. This indicates that the file reading time is minimal and scales linearly with the input size. The time overhead for reading the file is negligible compared to the sorting time, suggesting that the primary performance bottleneck lies in the sorting process.

## Data Tables

### Sorting Time for Different Attributes Using Lambda Function

| Attribute     | Full Input (ms)  | Half Input (ms) |
|---------------|------------------|-----------------|
| Name          | 33.23            | 16.12           |
| Job           | 32.90            | 15.45           |
| Phone Number  | 34.10            | 17.05           |

### Sorting Time for Different Attributes Using Custom Compare

| Attribute     | Full Input (ms)  | Half Input (ms) |
|---------------|------------------|-----------------|
| Name          | 181.31           | 90.65           |
| Job           | 163.17           | 81.58           |
| Phone Number  | 212.28           | 106.14          |

## Sorting Time for Different Sorting Approaches (Full Input Size)

|Sorting Approach | Name (ms) | Job (ms) | Phone Number (ms)
|----------------|-----------|----------|------------------|
|Bubble Sort     | 6272.95   | 10172.32 |   8262.15        |
|Quick Sort      | 4530.90   | 6162.05  |   5165.96        |
|Lambda Function |  20.82    | 20.20    |   19.05          |
|Attrgetter      |  13.98    | 15.49    |   16.73          |
|Custom Compare  |  115.07   | 97.78    |   105.88         |

## Performance Analysis

The data tables provide a comprehensive view of the performance of different sorting algorithms across varying input sizes and attributes. Below is an updated analysis based on the empirical results:

Bubble Sort

- Time Complexity: O(nÂ²).
- Performance: Bubble Sort is the least efficient algorithm, with runtimes increasing quadratically as the input size grows. For example, sorting the attribute name with the full input takes 6272.95 ms, while half input takes 2873.83 ms.
- Use Case: Suitable only for small datasets due to its simplicity and poor scalability.

Quick Sort

- Time Complexity: O(n log n).
- Performance: Quick Sort is highly efficient for large datasets, with runtimes increasing logarithmically. For example, sorting the attribute name with the full input takes 4530.90 ms, while half input takes 2321.42 ms.
- Use Case: Ideal for large datasets where performance is critical. However, it may not be stable and can have a worst-case time complexity of O(nÂ²) in specific scenarios.

Lambda Function

- Time Complexity: O(n log n).
- Performance: The lambda function approach is efficient, with runtimes increasing linearly with input size. For example, sorting the attribute name with the full input takes 18.69 ms, while half input takes 10.49 ms.
- Use Case: Suitable for custom sorting logic, but slightly slower than attrgetter due to the overhead of evaluating the lambda function.

Attrgetter

- Time Complexity: O(n log n).
- Performance: Similar to lambda function, but slightly faster due to its optimized implementation. For example, sorting the attribute name with the full input takes 13.98 ms, while half input takes 9.56 ms.
- Use Case: Ideal for sorting objects by specific attributes, offering a clean and efficient solution.

Custom Compare

- Time Complexity: O(n log n).
- Performance: The custom compare approach is slower than quick sort and attrgetter, but faster than bubble sort. For example, sorting the attribute name with the full input takes 115.07 ms, while half input takes 73.55 ms.
- Use Case: Useful for scenarios requiring highly customized sorting logic, but less efficient than other O(n log n) algorithms.

## Professional Development

### What are the benefits and drawbacks of the five approaches to sorting in Python?

The benefits of the five approaches to sorting in Python are:

- Lambda Function: This approach is easy to use. It allows for custom sorting logic without defining a separate function.
- Attrgetter: This approach is efficient for sorting objects based on attributes (like the sorting we had to do in this project). It provides a clean and readable way to sort objects by specific attributes.
- Custom Compare: This approach offers flexibility in defining custom sorting logic.
- Bubble Sort: This approach is easy to implement and understand. It is suitable for small datasets and simple sorting tasks.
- Quick Sort: This approach is efficient for large datasets and provides good performance with an average time complexity of O(n log n). It is widely used in practice for its speed and effectiveness.

The drawbacks of the five approaches to sorting in Python are:

- Lambda Function: This approach may not the best for complex sorting logic that requires multiple conditions or comparisons.
- Attrgetter: This approach may not be as flexible as custom compare for defining complex sorting criteria. It is limited to sorting by specific attributes of objects.
- Custom Compare: This approach may require more code and effort to define custom sorting logic. It can be more complex and harder to maintain compared to lambda function and attrgetter.
- Bubble Sort: This approach has a high time complexity of O(n^2), making it inefficient for large datasets.
- Quick Sort: This approach may not be stable and can have a worst-case time complexity of O(n^2) and it requires additional memory for recursion.

### What is challenging about designing an experiment to evaluate the performance of sorting?

Designing an experiment to evaluate the performance of sorting algorithms can be challenging due to several factors:

- Sorting algorithms: In my opinion, the sorting algorithms with the attributes are more complex algorithms and a little bit difficult to understand.
- Algorithm Selection: Selecting the right sorting algorithms to evaluate can be challenging. There are many sorting algorithms available, each with its strengths and weaknesses. It is crucial to choose algorithms that are suitable for the experiment's objectives and requirements.
- Performance Metrics: Defining the right performance metrics to evaluate the algorithms can be challenging. It is essential to choose metrics that accurately reflect the algorithms' performance and provide meaningful insights into their efficiency.

### How do the empirical results suggest that you don't yet know the entire story about the performance of sorting?

The empirical results suggest that there are still many factors to consider when evaluating the performance of sorting algorithms. While the experiments provide insights into the efficiency of different sorting approaches, they do not capture the full story of sorting performance. Several aspects need further investigation to gain a comprehensive understanding of sorting algorithms' performance:

## Take Home Points

This project allowed me to explore the performance of different sorting algorithms in Python and understand how the choice of algorithm can impact the runtime for different input sizes. By designing experiments and analyzing empirical results, I gained insights into the efficiency of sorting algorithms and the challenges of evaluating their performance. The results suggest that further investigation is needed to fully understand the performance characteristics of sorting algorithms and their suitability for different applications.
